<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VR Library — Community Encyclopedia</title>
<link rel="icon" type="image/x-icon" href="SCR-20251210-mghp.ico">

<!-- Fonts & Quill -->
<link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@300;400;700&family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
<link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">

<style>
/* ---------- Theme & layout ---------- */
:root{
  --glass: rgba(255,255,255,0.36);
  --glass-2: rgba(255,255,255,0.18);
  --accent: #7a4b1c;
  --accent-2: #b77b3d;
  --muted: #6b645b;
  --paper: #FFF7EA;
  --radius: 18px;
  --shadow: 0 18px 48px rgba(0,0,0,0.18);
}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, Arial;background:linear-gradient(180deg,#efe7d3,#f9f6f1);color:#222}
.container{max-width:1200px;margin:28px auto;padding:0 20px}

/* Header */
.header{display:flex;align-items:center;gap:14px;padding:18px;border-radius:20px;background:var(--glass);backdrop-filter:blur(12px) saturate(150%);box-shadow:var(--shadow)}
.brand{display:flex;flex-direction:column}
.logo{font-family:Merriweather,serif;font-size:22px;color:var(--accent);font-weight:700}
.sub{font-size:13px;color:var(--muted)}

/* Search */
.search{flex:1}
.input{width:100%;padding:12px 14px;border-radius:14px;border:none;background:var(--glass-2);font-size:15px}

/* Buttons: glassy & round */
.btn, .btn-outline, .chip, .small {
  border-radius:20px;padding:10px 14px;border:1px solid rgba(255,255,255,0.5);
  background:var(--glass);cursor:pointer;backdrop-filter:blur(12px);transition:all .22s;box-shadow:0 10px 30px rgba(0,0,0,0.12);
  font-weight:600;
}
.btn:hover, .btn-outline:hover, .small:hover { transform:translateY(-3px); }
.btn-outline{background:transparent}

/* Layout */
.layout{display:grid;grid-template-columns:260px 1fr 320px;gap:20px;margin-top:18px}
.sidebar, .feed, .rightcol{background:var(--paper);border-radius:16px;padding:16px;box-shadow:0 10px 28px rgba(0,0,0,0.06)}

/* Post card */
.post{display:flex;gap:14px;padding:14px;border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,0.98),rgba(249,246,241,0.98));border:1px solid rgba(43,43,43,0.04);transition:transform .2s, box-shadow .2s}
.post:hover{transform:translateY(-6px);box-shadow:0 18px 40px rgba(0,0,0,0.06)}
.avatar{width:56px;height:56px;border-radius:12px;background:linear-gradient(180deg,#fff,#f4efe5);display:flex;align-items:center;justify-content:center;font-weight:700;color:var(--accent)}

/* Comment Section */
.comments-section { 
  margin-top: 24px; 
  padding-top: 16px; 
  border-top: 1px solid rgba(0,0,0,0.08); 
  -webkit-tap-highlight-color: transparent;
}

.comment-form { 
  display: flex; 
  flex-direction: column;
  gap: 10px; 
  margin-bottom: 20px;
  position: relative;
}

.comment-input { 
  width: 100%;
  padding: 14px 16px; 
  border-radius: 16px; 
  border: 1px solid rgba(0,0,0,0.1); 
  min-height: 60px; 
  max-height: 200px;
  resize: none;
  font-size: 16px;
  line-height: 1.5;
  -webkit-appearance: none;
  appearance: none;
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
  transition: all 0.2s ease;
}

.comment-input:focus {
  border-color: var(--accent);
  outline: none;
  box-shadow: 0 0 0 3px rgba(122, 75, 28, 0.1);
}

.comment-btn { 
  align-self: flex-end;
  padding: 10px 20px; 
  background: var(--accent); 
  color: white; 
  border: none; 
  border-radius: 20px; 
  font-weight: 600;
  font-size: 15px;
  cursor: pointer; 
  transition: all 0.2s;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  -webkit-tap-highlight-color: rgba(0,0,0,0);
}

.comment-btn:active { 
  transform: scale(0.98);
  background: var(--accent-2);
}

.comment { 
  display: flex; 
  gap: 12px; 
  margin-bottom: 16px; 
  padding: 14px; 
  border-radius: 16px; 
  background: rgba(255,255,255,0.8);
  transition: transform 0.2s, background 0.2s;
  -webkit-tap-highlight-color: transparent;
}

.comment:active {
  background: rgba(0,0,0,0.02);
  transform: scale(0.995);
}

.comment-avatar { 
  flex: 0 0 40px;
  width: 40px; 
  height: 40px; 
  border-radius: 50%; 
  background: linear-gradient(135deg, #f5f5f5, #e0e0e0);
  display: flex; 
  align-items: center; 
  justify-content: center; 
  font-weight: bold; 
  color: var(--accent);
  font-size: 18px;
  text-transform: uppercase;
  user-select: none;
}

.comment-content { 
  flex: 1;
  min-width: 0; /* Prevents flex item from overflowing */
}

.comment-header { 
  display: flex; 
  justify-content: space-between; 
  align-items: center;
  margin-bottom: 6px; 
  gap: 8px;
  flex-wrap: wrap;
}

.comment-author { 
  font-weight: 600; 
  font-size: 15px; 
  color: #333;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 70%;
}

.comment-time { 
  font-size: 12px; 
  color: #999;
  white-space: nowrap;
}

.comment-text { 
  font-size: 15px; 
  line-height: 1.5; 
  color: #333; 
  margin-bottom: 10px;
  word-break: break-word;
  overflow-wrap: break-word;
  -webkit-hyphens: auto;
  -ms-hyphens: auto;
  hyphens: auto;
}

.comment-actions { 
  display: flex; 
  gap: 16px; 
  margin-top: 10px;
  flex-wrap: wrap;
}

.comment-action { 
  display: flex; 
  align-items: center; 
  gap: 6px; 
  font-size: 13px; 
  color: #666; 
  cursor: pointer; 
  transition: all 0.2s;
  padding: 4px 8px;
  border-radius: 12px;
  -webkit-tap-highlight-color: rgba(0,0,0,0.05);
}

.comment-action:active {
  background: rgba(0,0,0,0.05);
  transform: scale(0.96);
}

.comment-action.liked { 
  color: #ff4757;
  font-weight: 600;
}

/* Mobile-specific styles */
@media (max-width: 768px) {
  .comment-form {
    padding: 0 4px;
  }
  
  .comment-input {
    padding: 12px 14px;
    font-size: 15px;
  }
  
  .comment {
    padding: 12px 10px;
    margin-bottom: 14px;
    border-radius: 14px;
  }
  
  .comment-avatar {
    width: 36px;
    height: 36px;
    font-size: 16px;
  }
  
  .comment-author {
    font-size: 14px;
  }
  
  .comment-text {
    font-size: 14px;
    line-height: 1.45;
  }
  
  .comment-action {
    padding: 6px 10px;
    gap: 4px;
    font-size: 13px;
  }
  
  .comment-actions {
    gap: 12px;
  }
  
  /* Make sure buttons are big enough for touch */
  .comment-action, .comment-btn {
    min-height: 36px;
    min-width: 36px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
  }
  
  /* Prevent zoom on input focus on mobile */
  @media (max-width: 480px) {
    .comment-input, .comment-textarea {
      font-size: 16px !important;
    }
    
    /* Better touch targets */
    .comment-action {
      padding: 8px 12px;
    }
    
    /* Adjust modal padding on small screens */
    .modal {
      padding: 14px;
      width: 100%;
      max-width: 100%;
      height: 100%;
      border-radius: 0;
      margin: 0;
    }
    
    .comments-section {
      padding: 0 4px;
    }
  }
}

.post-title{font-family:Merriweather,serif;margin:0;font-size:18px}
.post-meta{color:var(--muted);font-size:13px;margin-top:6px}
.post-content{color:#333;margin-top:8px;margin-bottom:8px}
.post-images img{max-width:100%;border-radius:10px;margin-top:6px;cursor:zoom-in}

/* Modal */
.modal-backdrop{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:1200}
.modal{width:800px;max-width:96%;background:var(--glass);border-radius:20px;padding:18px;backdrop-filter:blur(20px) saturate(140%);box-shadow:0 30px 60px rgba(0,0,0,0.4);transform:scale(.96);opacity:0;transition:all .22s}
.modal.show{transform:scale(1);opacity:1}

/* Editor */
#editor{height:260px;background:white;border-radius:10px;padding:6px;overflow:auto}

/* Small helpers */
.tag{display:inline-block;padding:6px 8px;border-radius:999px;background:#f1e6d8;color:var(--accent);font-size:12px;margin-right:6px}
.kv{color:var(--muted);font-size:13px}
.filter-row{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px}

/* Responsive */
@media (max-width:1000px){
  .layout{grid-template-columns:1fr}
  .rightcol{order:3}
  .sidebar{order:2}
}
</style>
</head>
<body>
<div class="container">
  <header class="header">
    <div class="brand">
      <div class="logo">QForge</div>
      <div class="sub">A persistent community encyclopedia</div>
    </div>

    <div class="search"><input id="globalSearch" class="input" placeholder="Search titles, tags & content..."></div>

    <div style="display:flex;gap:10px;align-items:center">
      <div id="userInfo" style="display:flex;flex-direction:column;align-items:flex-end"><span id="userName" class="kv"></span></div>
      <button id="signInBtn" class="btn">Sign in with Google</button>
      <button id="newPostBtn" class="btn-outline">New Post</button>
    </div>
  </header>

  <div class="layout">
    <aside class="sidebar">
      <h3 style="margin:0 0 10px 0">Collections</h3>
      <div id="topicList"></div>
      <div style="height:12px"></div>
      <h3 style="margin:0 0 10px 0">Filters</h3>
      <div id="filterRow" class="filter-row"></div>
    </aside>

    <main class="feed" id="feed">
      <div id="postsContainer"></div>
    </main>

    <aside class="rightcol">
      <h3 style="margin:0 0 10px 0">Trending tags</h3>
      <div id="trending"></div>
      <div style="height:18px"></div>
      <h3 style="margin:0 0 10px 0">About</h3>
      <p class="kv">The VR Library stores community posts (articles with images and highlights). Moderators and admins can manage content. Use authorized domains and secure Firestore/Storage rules.</p>
      <div style="height:12px"></div>
      <div class="kv">Posts: <span id="statPosts">—</span></div>
      <div class="kv">Users: <span id="statUsers">—</span></div>
    </aside>
  </div>
</div>

<!-- Post Detail Modal -->
<div id="postDetailModal" class="modal">
  <div id="postDetailContent"></div>
  
  <!-- Comment Section -->
  <div class="comments-section">
    <h3>Comments</h3>
    <div id="commentsList"></div>
    
    <!-- Comment Form -->
    <div class="comment-form">
      <textarea id="commentInput" class="comment-input" placeholder="Write a comment..."></textarea>
      <button id="submitComment" class="comment-btn">Post</button>
    </div>
  </div>
  
  <button id="closeDetailModal" class="btn" style="margin-top: 20px;">Close</button>
</div>

<!-- New Post Modal -->
<div class="modal-backdrop" id="modalBackdrop">
  <div class="modal" id="postModal">
    <h2 style="margin-top:0">Create new post</h2>
    <div style="display:flex;gap:8px;margin-bottom:8px">
      <input id="postTitle" class="input" placeholder="Title (required)">
      <select id="postCategory" class="input" style="min-width:160px;border-radius:12px;padding:10px">
        <option>General</option><option>VR Science</option><option>History</option><option>Art</option>
      </select>
    </div>

    <div id="editor"></div>

    <div style="display:flex;gap:8px;margin-top:10px">
      <input id="postTags" class="input" placeholder="Tags (comma separated)">
      <input type="file" id="postImages" multiple accept="image/*">
    </div>

    <div id="postContent" class="ql-editor" style="min-height: 200px; padding: 20px;"></div>
    <div class="modal-actions">
      <button id="cancelPost" class="btn btn-outline">Cancel</button>
      <button id="submitPost" class="btn">Post</button>
    </div>
  </div>
</div>

<!-- View Modal -->
<div class="modal-backdrop" id="viewBackdrop">
  <div class="modal" id="viewModal"></div>
</div>

<!-- Zoom image overlay -->
<div class="modal-backdrop" id="zoomBackdrop" style="background:rgba(0,0,0,0.78)">
  <img id="zoomImg" style="max-width:92vw;max-height:92vh;border-radius:12px;box-shadow:0 18px 48px rgba(0,0,0,0.4)">
</div>

<!-- Quill -->
<script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>

<!-- Firebase (modular v9) -->
<script type="module">
/* ========= IMPORTS ========= */
import { initializeApp } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js';
import { getAuth, signInWithPopup, GoogleAuthProvider, signOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js';
import { getFirestore, collection, addDoc, onSnapshot, query, where, orderBy, serverTimestamp, doc, setDoc, getDoc, deleteDoc, getDocs } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js';
import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from 'https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js';

/* ========= FIREBASE CONFIG - REPLACE THIS BLOCK =========
   Paste your Firebase config object here (from Firebase Console)
   e.g.
   const firebaseConfig = {
     apiKey: "...",
     authDomain: "...",
     projectId: "...",
     storageBucket: "...",
     messagingSenderId: "...",
     appId: "..."
   };
   ======================================================= */
const firebaseConfig = {
   apiKey: "AIzaSyBWlj0gA31boKWZ8Rukj7oSUZbIqUsY6Sk",
  authDomain: "tipidi-tapap.firebaseapp.com",
  projectId: "tipidi-tapap",
  storageBucket: "tipidi-tapap.firebasestorage.app",
  messagingSenderId: "607716485574",
  appId: "1:607716485574:web:52a976161569ac79a06ac7",
  measurementId: "G-WJNZNZ4Q9Q"
}
if (!firebaseConfig || !firebaseConfig.apiKey) {
  console.warn("Firebase config not set. Paste your config into the script.");
}

/* ========= INITIALIZE ========= */
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const provider = new GoogleAuthProvider();
const db = getFirestore(app);
const storage = getStorage(app);

/* ========= UI references ========= */
const signInBtn = document.getElementById('signInBtn');
const userNameEl = document.getElementById('userName');
const newPostBtn = document.getElementById('newPostBtn');
const modalBackdrop = document.getElementById('modalBackdrop');
const postModal = document.getElementById('postModal');
const cancelPost = document.getElementById('cancelPost');
const submitPost = document.getElementById('submitPost');
const postTitle = document.getElementById('postTitle');
const postCategory = document.getElementById('postCategory');
const postTags = document.getElementById('postTags');
const postImages = document.getElementById('postImages');
const postsContainer = document.getElementById('postsContainer');
const globalSearch = document.getElementById('globalSearch');
const filterRow = document.getElementById('filterRow');
const topicList = document.getElementById('topicList');
const trending = document.getElementById('trending');
const statPosts = document.getElementById('statPosts');
const statUsers = document.getElementById('statUsers');
const viewBackdrop = document.getElementById('viewBackdrop');
const viewModal = document.getElementById('viewModal');
const zoomBackdrop = document.getElementById('zoomBackdrop');
const zoomImg = document.getElementById('zoomImg');

let currentUser = null;
let rolesCache = {};
let postsCache = {}; // id -> post

/* ========= Quill editor ========= */
const quill = new Quill('#editor', {
  theme: 'snow',
  modules: {
    toolbar: [
      [{ header: [1, 2, 3, false] }],
      ['bold', 'italic', 'underline', 'strike'],
      [{ 'list': 'ordered' }, { 'list': 'bullet' }],
      ['link', 'image'],
      [{ 'background': [] }, { 'color': [] }],
      ['clean']
    ]
  }
});

/* ========= Helpers: modal open/close ========= */
function openModal(){ modalBackdrop.style.display = 'flex'; setTimeout(()=> postModal.classList.add('show'), 10); }
function closeModal(){ postModal.classList.remove('show'); setTimeout(()=> modalBackdrop.style.display = 'none', 200); }
function openView(){ 
  viewBackdrop.style.display = 'flex'; 
  document.body.style.overflow = 'hidden';
  setTimeout(()=> viewModal.classList.add('show'), 8);
  
  // Add event listener for the close button when opening the modal
  setTimeout(() => {
    const closeBtn = viewModal.querySelector('.close-btn');
    if (closeBtn) {
      closeBtn.onclick = closeView;
    }
  }, 10);
}

function closeView(){ 
  viewModal.classList.remove('show'); 
  document.body.style.overflow = '';
  setTimeout(()=> {
    viewBackdrop.style.display = 'none';
    viewModal.innerHTML = '';
  }, 200);
}

// Close modal when clicking outside content
// Close modal when clicking outside content
viewBackdrop.addEventListener('click', function(e) {
  if (e.target === this) {
    closeView();
  }
});

// Close modal with Escape key
document.addEventListener('keydown', function(e) {
  if (e.key === 'Escape' && viewBackdrop.style.display === 'flex') {
    closeView();
  }
});
function openZoom(){ zoomBackdrop.style.display = 'flex'; }
function closeZoom(){ zoomBackdrop.style.display = 'none'; }

/* ========= Auth ========= */
signInBtn.addEventListener('click', async ()=>{
  if(!currentUser){
    try { await signInWithPopup(auth, provider); }
    catch(err){ alert('Sign-in failed: '+err.message); console.error(err); }
  } else {
    await signOut(auth);
  }
});

onAuthStateChanged(auth, async (user) => {
  currentUser = user;
  if(user){
    userNameEl.textContent = user.displayName || user.email;
    signInBtn.textContent = 'Sign out';
    // ensure role doc exists
    try{
      const r = await getDoc(doc(db,'roles',user.uid));
      if(!r.exists()) await setDoc(doc(db,'roles',user.uid), { role: 'user' });
      rolesCache[user.uid] = r.exists() ? r.data().role : 'user';
    }catch(e){ console.error(e); }
    // update stats
    updateStats();
  } else {
    userNameEl.textContent = '';
    signInBtn.textContent = 'Sign in with Google';
    updateStats();
  }
});

/* Quick open new post */
newPostBtn.addEventListener('click', ()=> {
  if(!currentUser){ alert('Please sign in to create a post'); return; }
  postTitle.value = ''; postTags.value = ''; postCategory.value = 'General'; postImages.value = ''; quill.setContents([]);
  openModal();
});
cancelPost.addEventListener('click', ()=> closeModal());

/* ========= Submit post (uploads images then saves doc) ========= */
async function uploadFileAndGetURL(file){
  const path = `postImages/${Date.now()}_${file.name.replace(/\s/g,'_')}`;
  const r = ref(storage, path);
  const snap = await uploadBytes(r, file);
  return await getDownloadURL(snap.ref);
}

submitPost.addEventListener('click', async ()=>{
  const title = postTitle.value.trim();
  const content = quill.root.innerHTML.trim();
  if(!title || !content || content === '<p><br></p>'){ alert('Title and content required'); return; }
  const tags = postTags.value.split(',').map(s=>s.trim()).filter(Boolean);
  const category = postCategory.value;

  const files = Array.from(postImages.files || []);
  const images = [];
  try{
    for(const f of files){
      const url = await uploadFileAndGetURL(f);
      images.push(url);
    }
  }catch(err){ alert('Image upload failed: '+err.message); console.error(err); return; }

  try{
    await addDoc(collection(db,'posts'), {
      title, content, tags, category,
      images, author: { uid: currentUser.uid, name: currentUser.displayName || 'Anonymous' },
      createdAt: serverTimestamp(), visible: true, featured: false
    });
    closeModal();
  }catch(err){ alert('Publish failed: '+err.message); console.error(err); }
});

/* ========= Real-time posts ========= */
const postsQuery = query(collection(db,'posts'), orderBy('createdAt','desc'));
onSnapshot(postsQuery, snapshot => {
  const posts = [];
  snapshot.forEach(docSnap => { posts.push({ id: docSnap.id, ...docSnap.data() }); });
  postsCache = {}; posts.forEach(p=> postsCache[p.id]=p);
  renderPosts(posts);
  computeTrending(posts);
  updateStats(posts);
});

/* ========= Render posts list ========= */
function renderPosts(posts){
  postsContainer.innerHTML = '';
  const q = globalSearch.value.trim().toLowerCase();
  const activeFilters = Array.from(filterRow.querySelectorAll('.active')).map(n=>n.dataset.filter);
  posts.forEach(post => {
    if(post.visible === false) return; // hidden
    if(q && !(post.title.toLowerCase().includes(q) || (post.tags||[]).join(' ').toLowerCase().includes(q) || stripTags(post.content).toLowerCase().includes(q))) return;
    if(activeFilters.length && !activeFilters.includes(post.category)) return;

    const el = document.createElement('div'); el.className = 'post';
    const avatar = shortName(post.author?.name || 'A');
    const timeStr = post.createdAt && post.createdAt.toDate ? timeAgo(post.createdAt.toDate()) : '';
    const tagsHtml = (post.tags || []).map(t=>`<span class="tag">${escapeHTML(t)}</span>`).join('');
    const imagesPreview = (post.images || []).slice(0,2).map(u=>`<img src="${u}" style="max-width:140px;border-radius:12px;margin-left:8px" onclick="zoomImage('${u}')">`).join('');

    el.innerHTML = `
      <div class="avatar">${avatar}</div>
      <div style="flex:1">
        <h3 class="post-title">${escapeHTML(post.title)}</h3>
        <div class="post-meta">by <strong>${escapeHTML(post.author?.name||'Anonymous')}</strong> • ${timeStr} • <span class="kv">${escapeHTML(post.category||'General')}</span></div>
        <div class="post-content">${shorten(stripTags(post.content), 260)}</div>
        <div>${tagsHtml}</div>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button class="small" onclick="viewPost('${post.id}')">View</button>
          <button class="small" onclick="flagPost('${post.id}')">Flag</button>
          <button class="small" onclick="bookmarkPost('${post.id}')">Bookmark</button>
          ${renderModerationButtons(post)}
        </div>
      </div>
      ${imagesPreview ? `<div style="display:flex;flex-direction:column;align-items:flex-end">${imagesPreview}</div>` : ''}
    `;
    postsContainer.appendChild(el);
  });
}

/* ========= View full post modal ========= */
// Function to render comments
async function renderComments(postId) {
  const commentsContainer = document.getElementById('comments-container');
  if (!commentsContainer) return;
  
  commentsContainer.innerHTML = '<div class="loading">Loading comments...</div>';
  
  try {
    // First check if we have an existing subscription and clean it up
    if (window.currentCommentsUnsubscribe) {
      window.currentCommentsUnsubscribe();
    }
    
    const commentsQuery = query(
      collection(db, 'comments'),
      where('postId', '==', postId),
      orderBy('createdAt', 'desc')
    );
    
    // Use getDocs for initial load to catch any errors
    const querySnapshot = await getDocs(commentsQuery);
    
    const updateCommentsUI = (comments) => {
      if (comments.length === 0) {
        commentsContainer.innerHTML = '<div class="no-comments">No comments yet. Be the first to comment!</div>';
        return;
      }
      
      commentsContainer.innerHTML = comments
        .sort((a, b) => b.createdAt?.seconds - a.createdAt?.seconds) // Sort by newest first
        .map(comment => {
          const commentTime = comment.createdAt?.toDate 
            ? comment.createdAt.toDate().toLocaleString() 
            : (comment.createdAt?.seconds 
                ? new Date(comment.createdAt.seconds * 1000).toLocaleString() 
                : 'Just now');
          
          const isAuthor = currentUser && comment.userId === currentUser.uid;
          const isAdmin = currentUser && rolesCache[currentUser.uid] === 'admin';
          
          return `
            <div class="comment" id="comment-${comment.id}" style="margin: 10px 0; padding: 10px; border: 1px solid #eee; border-radius: 4px;">
              <div class="comment-header" style="display: flex; align-items: center; margin-bottom: 8px;">
                <strong style="margin-right: 10px;">${escapeHTML(comment.authorName || 'Anonymous')}</strong>
                <span class="comment-time" style="color: #666; font-size: 0.9em;">${commentTime}</span>
                ${(isAuthor || isAdmin) ? `
                  <button class="small" onclick="event.stopPropagation(); deleteComment('${comment.id}')" 
                    style="margin-left: auto; padding: 2px 8px; font-size: 0.8em;">
                    Delete
                  </button>
                ` : ''}
              </div>
              <div class="comment-content" style="white-space: pre-wrap;">${escapeHTML(comment.content)}</div>
            </div>
          `;
        })
        .join('');
    };
    
    // Initial render
    const initialComments = [];
    querySnapshot.forEach(doc => {
      initialComments.push({ id: doc.id, ...doc.data() });
    });
    updateCommentsUI(initialComments);
    
    // Set up real-time listener
    const unsubscribe = onSnapshot(commentsQuery, 
      (snapshot) => {
        const updatedComments = [];
        snapshot.forEach(doc => {
          updatedComments.push({ id: doc.id, ...doc.data() });
        });
        updateCommentsUI(updatedComments);
      },
      (error) => {
        console.error('Error in comments listener:', error);
        commentsContainer.innerHTML = `
          <div class="error" style="color: #d32f2f; padding: 10px; background: #ffebee; border-radius: 4px;">
            Error loading comments. ${error.message || ''}
          </div>
        `;
      }
    );
    
    // Store unsubscribe function for cleanup
    window.currentCommentsUnsubscribe = unsubscribe;
    
  } catch (error) {
    console.error('Error loading comments:', error);
    commentsContainer.innerHTML = `
      <div class="error" style="color: #d32f2f; padding: 10px; background: #ffebee; border-radius: 4px;">
        Error loading comments: ${error.message || 'Unknown error'}
      </div>
    `;
  }
}

// Function to add a new comment
window.addComment = async function(postId) {
  if (!currentUser) {
    alert('Please sign in to comment');
    return;
  }
  
  const commentInput = document.getElementById('comment-input');
  const content = commentInput.value.trim();
  
  if (!content) {
    alert('Please enter a comment');
    return;
  }
  
  const commentButton = document.querySelector('button[onclick^="addComment("]');
  const originalText = commentButton.textContent;
  
  try {
    commentButton.disabled = true;
    commentButton.textContent = 'Posting...';
    
    // Add the comment
    await addDoc(collection(db, 'comments'), {
      postId,
      content,
      userId: currentUser.uid,
      authorName: currentUser.displayName || currentUser.email.split('@')[0],
      createdAt: serverTimestamp()
    });
    
    // Clear the input
    commentInput.value = '';
    
  } catch (error) {
    console.error('Error adding comment:', error);
    alert('Failed to add comment: ' + (error.message || 'Unknown error'));
  } finally {
    commentButton.disabled = false;
    commentButton.textContent = originalText;
  }
};

// Function to delete a comment
window.deleteComment = async function(commentId) {
  if (!currentUser) return;
  
  try {
    const commentRef = doc(db, 'comments', commentId);
    const commentDoc = await getDoc(commentRef);
    
    if (!commentDoc.exists()) {
      alert('Comment not found');
      return;
    }
    
    const commentData = commentDoc.data();
    const isAdmin = rolesCache[currentUser.uid] === 'admin';
    
    if (commentData.userId !== currentUser.uid && !isAdmin) {
      alert('You can only delete your own comments');
      return;
    }
    
    if (confirm('Are you sure you want to delete this comment?')) {
      await deleteDoc(commentRef);
    }
    
  } catch (error) {
    console.error('Error deleting comment:', error);
    alert('Failed to delete comment. Please try again.');
  }
};

window.viewPost = function(id){
  const post = postsCache[id];
  if(!post){ alert('Post not found'); return; }
  const timeStr = post.createdAt && post.createdAt.toDate ? post.createdAt.toDate().toLocaleString() : '';
  const tagsHtml = (post.tags || []).map(t=>`<span class="tag">${escapeHTML(t)}</span>`).join('');
  const imagesHtml = (post.images || []).map(u=>`<img src="${u}" style="max-width:100%;margin-top:10px;border-radius:12px;cursor:zoom-in" onclick="zoomImage('${u}')">`).join('');
  const adminBtns = (currentUser && rolesCache[currentUser.uid] && ['admin','moderator'].includes(rolesCache[currentUser.uid])) ? `
    <div style="margin-top:10px;display:flex;gap:8px">
      <button class="small" onclick="openEdit('${post.id}')">Edit</button>
      <button class="small" onclick="toggleVisibility('${post.id}')">${post.visible? 'Hide':'Unhide'}</button>
      <button class="small" onclick="deletePostPermanent('${post.id}')">Delete</button>
      <button class="small" onclick="warnUserPrompt('${post.id}')">Warn</button>
      <button class="small" onclick="muteUserPrompt('${post.id}')">Mute</button>
    </div>` : '';

  // Check if post is bookmarked
  const isBookmarked = currentUser && localStorage.getItem(`bookmark_${currentUser.uid}_${id}`) === 'true';
  
  viewModal.innerHTML = `
    <div style="position: relative;">
      <button class="close-btn" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 24px; cursor: pointer; z-index: 10;">×</button>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
        <h2 style="margin:0">${escapeHTML(post.title)}</h2>
      </div>
      <div class="kv">by <strong>${escapeHTML(post.author?.name||'Anonymous')}</strong> • ${timeStr}</div>
      <div style="margin-top:12px">${post.content}</div>
      ${imagesHtml}
      <div style="margin-top:10px">${tagsHtml}</div>
      <div style="margin-top:16px;display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <button class="small" onclick="bookmarkPost('${id}')">
          ${isBookmarked ? '★ Bookmarked' : '☆ Bookmark'}
        </button>
        <button class="small" onclick="flagPost('${id}')">
          ⚐ Flag
        </button>
      </div>
      ${adminBtns}
      
      <!-- Comments Section -->
      <div style="margin-top: 30px; border-top: 1px solid #eee; padding-top: 20px;">
        <h3>Comments</h3>
        <div id="comments-container" style="margin: 15px 0;">
          <div class="loading">Loading comments...</div>
        </div>
        ${currentUser ? `
          <div style="margin-top: 20px;">
            <textarea 
              id="comment-input" 
              placeholder="Write a comment..." 
              style="width: 100%; min-height: 80px; padding: 10px; border-radius: 4px; border: 1px solid #ddd; margin-bottom: 10px;"
            ></textarea>
            <button class="small" onclick="addComment('${id}')">Post Comment</button>
          </div>
        ` : `
          <div style="text-align: center; margin: 20px 0;">
            <a href="#" onclick="document.querySelector('.sign-in').click(); return false;">Sign in</a> to leave a comment
          </div>
        `}
      </div>
    </div>
  `;
  
  // Load comments
  renderComments(id);
  openView();
};

// Flag a post
window.flagPost = async function(postId) {
  if (!currentUser) {
    alert('Please sign in to flag posts');
    return;
  }
  
  const confirmFlag = confirm('Are you sure you want to flag this post? It will be reviewed by moderators.');
  if (!confirmFlag) return;
  
  try {
    // Add flag to database
    await addDoc(collection(db, 'flags'), {
      postId,
      userId: currentUser.uid,
      timestamp: serverTimestamp(),
      status: 'pending'
    });
    
    alert('Thank you for flagging this post. Our moderators will review it.');
  } catch (err) {
    console.error('Error flagging post:', err);
    alert('Failed to flag post. Please try again.');
  }
};

// Bookmark a post
window.bookmarkPost = function(postId) {
  if (!currentUser) {
    alert('Please sign in to bookmark posts');
    return;
  }
  
  const storageKey = `bookmark_${currentUser.uid}_${postId}`;
  const isBookmarked = localStorage.getItem(storageKey) === 'true';
  
  // Toggle bookmark
  localStorage.setItem(storageKey, (!isBookmarked).toString());
  
  // Update UI if we're viewing the post
  if (viewBackdrop.style.display === 'flex') {
    const btn = document.querySelector(`#viewModal button[onclick*="bookmarkPost('${postId}')"]`);
    if (btn) {
      btn.innerHTML = !isBookmarked ? '★ Bookmarked' : '☆ Bookmark';
    }
  }
  
  // Update the post list if needed
  const postEl = document.querySelector(`.post [onclick*="bookmarkPost('${postId}')"]`);
  if (postEl) {
    postEl.innerHTML = !isBookmarked ? 'Bookmarked' : 'Bookmark';
  }
};

/* ========= Zoom image ========= */
window.zoomImage = function(url){
  zoomImg.src = url;
  openZoom();
};
zoomBackdrop.addEventListener('click', ()=> closeZoom());

/* ========= Moderation helpers ========= */
function renderModerationButtons(post){
  if(!currentUser) return '';
  const role = rolesCache[currentUser.uid] || 'user';
  if(role === 'admin' || role === 'moderator'){
    return `<button class="small" onclick="openEdit('${post.id}')">Edit</button>
            <button class="small" onclick="toggleVisibility('${post.id}')">${post.visible? 'Hide':'Unhide'}</button>
            <button class="small" onclick="deletePostPermanent('${post.id}')">Delete</button>`;
  }
  return '';
}

window.openEdit = function(id){
  const post = postsCache[id];
  if(!post) return alert('Post not found');
  postTitle.value = post.title;
  postCategory.value = post.category || 'General';
  postTags.value = (post.tags || []).join(',');
  quill.root.innerHTML = post.content;
  postModal.dataset.editId = id;
  openModal();
};

window.toggleVisibility = async function(id){
  const p = postsCache[id];
  try{
    await setDoc(doc(db,'posts',id), { visible: !p.visible }, { merge: true });
  }catch(e){ alert('Operation failed: '+e.message); }
};

window.deletePostPermanent = async function(id){
  if(!confirm('Permanently delete this post? This cannot be undone.')) return;
  try{
    await deleteDoc(doc(db,'posts',id));
    // Optionally delete storage images with Cloud Function
  }catch(e){ alert('Delete failed: '+e.message); }
};

/* ========= Flags, warnings, mute, bookmarks ========= */
window.flagPost = async function(id){
  try{ await setDoc(doc(db,'flags',id), { postId: id, by: currentUser?.uid || null, at: serverTimestamp() }); alert('Flagged for review'); }catch(e){ alert('Flag failed: '+e.message); }
};

window.warnUserPrompt = async function(postId){
  const p = postsCache[postId];
  if(!p) return;
  const reason = prompt('Enter warning message for user:');
  if(!reason) return;
  try{ await addDoc(collection(db,'warnings'), { uid: p.author.uid, postId, reason, by: currentUser.uid, at: serverTimestamp() }); alert('Warning recorded'); }catch(e){ alert('Failed: '+e.message); }
};

window.muteUserPrompt = async function(postId){
  const p = postsCache[postId];
  if(!p) return;
  if(!confirm('Mute this user (set role to muted)?')) return;
  try{ await setDoc(doc(db,'roles',p.author.uid), { role: 'muted' }, { merge: true }); alert('User muted'); }catch(e){ alert('Failed: '+e.message); }
};

window.bookmarkPost = async function(id){
  if(!currentUser){ alert('Sign in to bookmark'); return; }
  try{ await setDoc(doc(db,'bookmarks', currentUser.uid + '_' + id), { uid: currentUser.uid, postId: id, savedAt: serverTimestamp() }); alert('Bookmarked'); }catch(e){ alert('Failed: '+e.message); }
};

/* alias the earlier name used in UI */
window.bookmarkPost = window.bookmarkPost;
window.bookmark = window.bookmarkPost;

/* ========= Editing / publishing when editing ========= */
submitPost.addEventListener('click', async ()=>{
  const editId = postModal.dataset.editId;
  if(editId){
    // update record
    const title = postTitle.value.trim();
    const content = quill.root.innerHTML.trim();
    const tags = postTags.value.split(',').map(s=>s.trim()).filter(Boolean);
    try{
      await setDoc(doc(db,'posts',editId), { title, content, tags, category: postCategory.value }, { merge: true });
      delete postModal.dataset.editId;
      closeModal();
    }catch(e){ alert('Update failed: '+e.message); }
    return;
  }
  // else normal create flow - handled above in earlier submit handler; to avoid duplication we keep single handler earlier
});

/* ========= Trending & Stats ========= */
function computeTrending(posts){
  const counts = {};
  posts.forEach(p=> (p.tags||[]).forEach(t=> counts[t] = (counts[t]||0) + 1));
  const arr = Object.entries(counts).sort((a,b)=>b[1]-a[1]).slice(0,8);
  trending.innerHTML = arr.map(a=>`<div style="margin-bottom:6px"><span class="tag">${escapeHTML(a[0])}</span> <span class="kv">(${a[1]})</span></div>`).join('');
}

async function updateStats(posts){
  try{
    statPosts.textContent = posts ? posts.length : (await getDocs(collection(db,'posts'))).size;
    statUsers.textContent = (await getDocs(collection(db,'roles'))).size;
  }catch(e){ console.error(e); }
}

/* ========= Utilities ========= */
function escapeHTML(s){ if(!s) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function stripTags(s){ return s ? String(s).replace(/<[^>]*>?/gm,'') : ''; }
function shorten(s,n){ s = stripTags(s||''); return s.length>n ? escapeHTML(s.slice(0,n)) + '…' : escapeHTML(s); }
function shortName(name){ if(!name) return 'A'; return name.split(' ').map(s=>s[0]).slice(0,2).join('').toUpperCase(); }
function timeAgo(d){ if(!d) return ''; const sec = Math.floor((Date.now()-d.getTime())/1000); if(sec<60) return sec+'s'; if(sec<3600) return Math.floor(sec/60)+'m'; if(sec<86400) return Math.floor(sec/3600)+'h'; return Math.floor(sec/86400)+'d'; }

/* ========= Init UI: filters & topics ========= */
const categories = ['General','VR Science','History','Art'];
categories.forEach(cat=>{
  const b = document.createElement('button'); b.className='chip'; b.innerText=cat; b.dataset.filter=cat;
  b.addEventListener('click', ()=> b.classList.toggle('active'));
  filterRow.appendChild(b);

  const a = document.createElement('a'); a.href='#'; a.innerText=cat; a.style.display='block'; a.style.color='var(--accent)'; a.style.marginBottom='6px';
  a.addEventListener('click', e=>{ e.preventDefault(); document.querySelectorAll('.chip').forEach(c=>c.classList.remove('active')); b.classList.add('active'); });
  topicList.appendChild(a);
});

/* ========= Search debounce ========= */
let searchTimer = null;
globalSearch.addEventListener('input', ()=>{
  clearTimeout(searchTimer);
  searchTimer = setTimeout(()=> renderPosts(Object.values(postsCache)), 220);
});

/* ========= Helper: flag list count (simple) ========= */
async function computeFlagCount(){ try{ const flags = await getDocs(collection(db,'flags')); return flags.size; }catch(e){ return 0; } }

/* ========= Utilities exposure for inline onclicks ========= */
window.viewPost = window.viewPost;
window.toggleVisibility = window.toggleVisibility;
window.deletePostPermanent = window.deletePostPermanent;
window.warnUserPrompt = window.warnUserPrompt;
window.muteUserPrompt = window.muteUserPrompt;
window.zoomImage = window.zoomImage;
window.bookmarkPost = window.bookmarkPost;

/* ========= Final console note ========= */
console.log('VR Library loaded — paste firebaseConfig and enable Google Sign-in and Firestore/Storage.');
</script>
<script src="https://www.chatbase.co/chatbot.js" defer></script>
<script>
(function(){
  if(!window.chatbase || window.chatbase("getState") !== "initialized") {
    window.chatbase = function(...args) {
      if(!window.chatbase.q) { window.chatbase.q = []; }
      window.chatbase.q.push(args);
    };
    window.chatbase = new Proxy(window.chatbase, {
      get(target, prop) {
        if(prop === "q") { return target.q; }
        return function(...args) { return target(prop, ...args); };
      }
    });
  }
  const onLoad = function() {
    const script = document.createElement("script");
    script.src = "https://www.chatbase.co/embed.min.js";
    script.id = "7azoXjl8yiQjUw5L0W0-T";
    script.domain = "www.chatbase.co";
    document.body.appendChild(script);
  };
  if(document.readyState === "complete") {
    onLoad();
  } else {
    window.addEventListener("load", onLoad);
  }
})();
</script>
</body>
</html>
